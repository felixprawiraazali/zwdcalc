<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ZWDS 13-Palace Responsive Sections without A3</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" type="text/css" href="./css/style.css">
</head>
<body class="bg-gray-100 text-gray-600">
  <div class="max-w-4xl mx-auto p-6 space-y-8">
		<!-- Form -->
		<form id="chartForm" class="bg-white p-6 rounded-lg shadow space-y-6">
		  <h2 class="text-2xl font-semibold">Plot Zi Wei Dou Shu Chart</h2>

		  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
				<!-- Name -->
				<div>
				  <label class="block font-medium">Name</label>
				  <input id="name" name="name" type="text"
						 class="mt-1 w-full border rounded p-2"
						 placeholder="e.g. Felix Prawira">
				</div>

				<!-- Birth Date -->
				<div class="space-y-1">
				  <label class="block font-medium">Birth Date</label>
				  <div class="flex gap-2">
					<input id="year"  name="year"  type="number" placeholder="YYYY" class="w-1/3 border rounded p-2">
					<input id="month" name="month" type="number" placeholder="MM"   class="w-1/3 border rounded p-2">
					<input id="day"   name="day"   type="number" placeholder="DD"   class="w-1/3 border rounded p-2">
				  </div>
				</div>

				<!-- Birth Time -->
				<div class="space-y-1">
				  <label class="block font-medium">Birth Time</label>
				  <div class="flex gap-2">
					<input id="hour"   name="hour"   type="number" placeholder="HH" class="w-1/2 border rounded p-2">
					<input id="minute" name="minute" type="number" placeholder="MM" class="w-1/2 border rounded p-2">
				  </div>
				</div>

				<!-- Gender -->
				<div>
				  <label class="block font-medium">Gender</label>
				  <div class="mt-1 flex gap-4">
					<label><input type="radio" name="gender" value="male"> Male</label>
					<label><input type="radio" name="gender" value="female"> Female</label>
				  </div>
				</div> 

	    	<!-- Reference Year Dropdown -->
				<div>
		      <label class="block font-medium">Reference Year</label>
		      <select id="refYear" name="refYear" class="mt-1 w-full border rounded p-2"></select>
		    </div>       
		  </div>

		  <button type="submit"
				  class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
				Plot Chart
		  </button>
		</form>

  	<div class="zwds-grid">
			<template id="palace-template">
			  <div class="sectionA">
				<div class="sectionA1"></div>
				<div class="sectionA2"></div>
			  </div>
			  <div class="sectionB">
				<div class="sectionB1">
				  <div class="sectionB1-1"></div>
				  <div class="sectionB1-2"></div>
				</div>
				<div class="sectionB2">
				  <div class="sectionB2-1"></div>
				  <div class="sectionB2-2"></div>
				</div>
				<div class="sectionB3">
				  <div class="sectionB3-1"></div>
				  <div class="sectionB3-2"></div>
				</div>
			  </div>
			</template>
			<svg id="lineLayer" class="absolute top-0 left-0 w-full h-full pointer-events-none">
				<defs>
			    <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5"
            markerWidth="6" markerHeight="6" orient="auto-start-reverse">
			      <path d="M 0 0 L 10 5 L 0 10 z" fill="context-stroke" />
			    </marker>
			  </defs>
			</svg>
			<svg id="shortLineLayer" class="absolute top-0 left-0 w-full h-full pointer-events-none">
				<defs>
			    <marker id="arrowShort" viewBox="0 0 10 10" refX="10" refY="5"
            markerWidth="6" markerHeight="6" orient="auto-start-reverse">
			      <path d="M 0 0 L 10 5 L 0 10 z" fill="context-stroke" />
			    </marker>
			  </defs>
			</svg>
	  </div>	
  </div>

	<script src="./js/iztro.js"></script>
	<script src="./js/stars_mapping.js"></script>
	<script src="./js/transformation.js"></script>
	<script>
		let lastClickPalace = -1
		const refYearSelect = document.getElementById('refYear');
	  let currentYear = new Date().getFullYear();
	  let urlParams = new URLSearchParams(window.location.search);
	  let refYearParam = parseInt(urlParams.get('refYear'), 10);
	  if (!isNaN(refYearParam)) {
	    currentYear = refYearParam;
	  }

	  let cn_year = getChineseYearPinyin(currentYear)

	  for (let y = 1984; y <= currentYear + 80; y++) {
	    const option = document.createElement('option');
	    option.value = y;
	    option.textContent = y;
	    if (y === currentYear) option.selected = true;
	    refYearSelect.appendChild(option);
	  }

		const labels = [
		  { code: "L", color: "green", circle: "Ⓛ"},
		  { code: "Q", color: "blue", circle: "Ⓠ" },
		  { code: "K", color: "orange", circle: "Ⓚ" },
		  { code: "J", color: "red", circle: "Ⓙ" }
		];

		const palaceOpposites = [
			{ opposite: 11, direction: "bottom-right" },
			{ opposite: 10, direction: "bottom" },
			{ opposite: 9,  direction: "bottom" },
			{ opposite: 8,  direction: "bottom-left" },
			{ opposite: 7,  direction: "right" },
			{ opposite: 6,  direction: "left" },
			{ opposite: 5,  direction: "right" },
			{ opposite: 4,  direction: "left" },
			{ opposite: 3,  direction: "top-right" },
			{ opposite: 2,  direction: "top" },
			{ opposite: 1,  direction: "top" },
			{ opposite: 0,  direction: "top-left" }
		];

		function parseQuery() {
			return Object.fromEntries(new URLSearchParams(window.location.search));
		}

		function fillForm(params) {
			for (let key of ['name','year','month','day','hour','minute','location','latitude','longitude']) {
				if (params[key]) {
					document.getElementById(key).value = params[key];
				}
			}
			if (params.gender) {
				document.querySelector(`input[name="gender"][value="${params.gender}"]`)?.click();
			}
		}

		function capitalizeFirstLetter(str) {
			return str.charAt(0).toUpperCase() + str.slice(1);
		}

		function toChineseHourIndex(t) {
		  let h;
		  if (t instanceof Date) {
		    h = t.getHours();
		  } else if (typeof t === 'string') {
		    h = parseInt(t.split(':', 1)[0], 10);
		  } else {
		    h = Number(t);
		  }
		  if (h === 0)   return 0;                 // 00:00–00:59 → early Rat
		  if (h === 23)  return 12;                  // 23:00–23:59 → late Rat
		  // 01–22 → floor((h+1)/2) gives 1…11
		  
		  return Math.floor((h + 1) / 2);
		}

		function getAgesInRange(origAges, min, max) {
			// make a copy so we don’t clobber the original
			const allAges = [...origAges];
			// find those already in range
			let inRange = allAges.filter(age => age >= min && age <= max);

			// if none, keep adding 12 to the highest until one falls in range
			if (inRange.length === 0) {
				let highest = Math.max(...allAges);
				// loop until highest is within [min, max]
				if (max > highest) {
		      // keep bumping by 12 until we reach at least min
		      while (highest < min) {
		        highest += 12;
		        allAges.push(highest);
		      }
		      // re-filter now that we’ve added new data
		      inRange = allAges.filter(age => age >= min && age <= max);
		    }
			}

			return inRange;
		}

		const isWithinRange = (val, min, max) => val >= min && val <= max;

		const astro = iztro.astro 

		let defaultIndex = 5
		let indexMap = [3,4,5,6,2,7,1,8,0,11,10,9]
		let astrolabe = null

		const lineRedrawQueue = [];
		function registerResizeRedraw(fn) {
		  lineRedrawQueue.push(fn);
		}

		function redrawAllLines() {
		  document.getElementById("lineLayer")?.querySelectorAll("line").forEach(line => line.remove());
		  document.getElementById("shortLineLayer")?.querySelectorAll("line").forEach(line => line.remove());
		  lineRedrawQueue.forEach(fn => fn());
		}

		function clearLineRedrawQueue() {
		  lineRedrawQueue.length = 0
		}

  	function generateChart(params) {
  		clearLineRedrawQueue()
  		cn_year = getChineseYearPinyin(params.refYear)
			let dob = params.year+'-'+params.month+'-'+params.day
			let timing = params.hour+':'+params.minute
			
			astrolabe = astro.bySolar(dob, toChineseHourIndex(timing), params.gender, true, 'en-US');
			let data = JSON.stringify(astrolabe, null, 1)
			// console.log(data)			

			let currentAge = parseInt(params.refYear) - parseInt(params.year) + 1

			const chineseYear = astrolabe.chineseDate.split(' - ')[0]
			let [heavenlyStem, startingPoint] = chineseYear.split(' ')

			let startFrom = 0
			let direction = 'clockwise'

			const container = document.querySelector('.zwds-grid');
			container.querySelectorAll("div:not(#lineLayer):not(#shortLineLayer)").forEach(el => el.remove());
			const tpl = document.getElementById('palace-template').content;

			const contextMenu = document.createElement('div');
			contextMenu.id = 'custom-menu';
			contextMenu.innerHTML = '<div id="transform-option">Transform Decade</div>';
			document.body.appendChild(contextMenu);

			// Hide menu when clicking outside
			document.addEventListener('click', () => {
				contextMenu.style.display = 'none';
			});

			for (let i = 0; i <= 11; i++) {
				let astroData = astrolabe.palaces[indexMap[i]]
				const cell = document.createElement('div');
				cell.className = 'p' + i;
				cell.id = 'p' + i;
				cell.dataset.palace = i;
				cell.dataset.heavenlyStem = astroData.decadal.heavenlyStem
				const clone = tpl.cloneNode(true);
				let [min, max] = astroData.decadal.range;

				if (isWithinRange(currentAge, min, max)) {
					defaultIndex = i					
				}
				if (astroData.earthlyBranch == startingPoint) {
					startFrom = i
					if (astroData.ages[0] > astrolabe.palaces[indexMap[i]+1 == 12 ? 0 : indexMap[i] + 1].ages[0]) {
						direction = 'counter-clockwise'
					}
				}

				let major = astroData.majorStars
					.filter(star => onlyShowStars().includes(star.name))
					.map(mj => stars.find(star => star.en === mj.name) ?? '')

				let minor = astroData.minorStars
					.filter(star => onlyShowStars().includes(star.name))
					.map(mn => stars.find(star => star.en === mn.name) ?? '')

				const markedNames = major.map(e => {
				  const heavenly_transformation = (() => {
					  const st = getTransformationType(heavenlyStem, e.key);
					  return st != null ? ` <label style="color: ${labels[st].color};">${labels[st].code}</label>` : "";
					})();

				  const self_transformation = (() => {
					  const st = getTransformationType(astroData.decadal.heavenlyStem, e.key);
					  return st != null ? ` <label style="color: ${labels[st].color};">${labels[st].code}↑</label>` : "";
					})();

					const yearly_transformation = (() => {
					  const st = getTransformationType(cn_year[0], e.key);
					  return st != null ? ` <label style="color: ${labels[st].color};">${labels[st].circle}</label>` : "";
					})();

		      return `<span class="major" id="${e.key}">${e.en}${heavenly_transformation}${self_transformation}${yearly_transformation}</span>`;
		    }).join('');
							
				clone.querySelector('.sectionA1').innerHTML = `
					${markedNames} 
					${minor.map(e => `<span class="minor" id="${e.key}">${e.en}</span>`).join('')}
				`;
				clone.querySelector('.sectionA2').innerHTML = `
					${major.map(e => `<span class="major">${e.zh}</span>`).join('')} 
					${minor.map(e => `<span class="minor">${e.zh}</span>`).join('')}
				`;
				clone.querySelector('.sectionB1-1').textContent = capitalizeFirstLetter(astroData.heavenlyStem)
				clone.querySelector('.sectionB1-2').textContent = capitalizeFirstLetter(astroData.earthlyBranch)
				clone.querySelector('.sectionB2-1').textContent = '';
				clone.querySelector('.sectionB2-2').textContent = '';
				clone.querySelector('.sectionB3-1').textContent = capitalizeFirstLetter(astroData.name)
				clone.querySelector('.sectionB3-2').textContent = astroData.decadal.range.join('-')

				cell.addEventListener('click', function() {
            setTransformationArrow(i)
        })

        cell.addEventListener('contextmenu', function (event) {
					event.preventDefault();
					contextMenu.style.display = 'block';
					contextMenu.style.left = event.pageX + 'px';
					contextMenu.style.top = event.pageY + 'px';
					contextMenu.dataset.palaceIndex = i; // Store the index for use on click
				});
				cell.appendChild(clone);
				container.appendChild(cell);
			}
			
			for (let i = 0; i <= 11; i++) {
				let astroData = astrolabe.palaces[indexMap[i]]
				if (i == startFrom) {
					astrolabe.palaces[indexMap[i]].ages = []
					let j = -11
					while (astrolabe.palaces[indexMap[i]].ages.length < 10) {
						j += 12
						astrolabe.palaces[indexMap[i]].ages.push(j)
					}
				} else {
					let distance = 0
					if (direction == 'clockwise') {
						let astroStart = indexMap[startFrom]
						let astroCurrent = indexMap[i]
						distance = astroCurrent - astroStart
						if (astroCurrent < astroStart) {
							distance += 12
						}
					} else {
						let astroStart = indexMap[startFrom]
						let astroCurrent = indexMap[i]
						distance = astroStart - astroCurrent
						if (distance < 0) {
							distance += 12
						}						
					}

					astrolabe.palaces[indexMap[i]].ages = []
					let j = -11 + distance
					
					while (astrolabe.palaces[indexMap[i]].ages.length < 10) {
						j = j + 12
						
						astrolabe.palaces[indexMap[i]].ages.push(j)
					}
				}
			}

			document.getElementById('transform-option').addEventListener('click', function () {
				const palaceIndex = contextMenu.dataset.palaceIndex;				
				setPalaceAge(palaceIndex)
				contextMenu.style.display = 'none';
			});
			
			const center = document.createElement('div');
			center.className = 'p13';

			const leftDiv = document.createElement('div');
			leftDiv.className = 'left'
			leftDiv.innerHTML = `
				${params.name} <br>
				${astrolabe.solarDate} (${currentAge}) <br>
				${params.hour}:${params.minute} ${astrolabe.time}
			`;

			const rightDiv = document.createElement('div');
			rightDiv.className = 'right'
			rightDiv.innerHTML = ``;

			center.appendChild(leftDiv);
			center.appendChild(rightDiv);
			container.appendChild(center);

			setPalaceAge()

			showShortLines()
		}

		function onlyShowStars() {
			return [
				"Zi Wei",
				"Tian Ji",
				"Tai Yang",
				"Wu Qu",
				"Tian Tong",
				"Lian Zhen",
				"Tian Fu",
				"Tai Yin",
				"Tan Lang",
				"Ju Men",
				"Tian Xiang",
				"Tian Liang",
				"Qi Sha",
				"Po Jun",
				"Zuo Fu",
				"You Bi",
				"Wen Chang",
				"Wen Qu",
			]
		}

		function setPalaceAge(p = null) {
			if (p == null) {
				p = defaultIndex
			}
			let indexSelectedPalace = indexMap[p]
			
			let selectedPalace = astrolabe.palaces[indexSelectedPalace]			
			let [min, max] = selectedPalace.decadal.range
			for (let i = 0; i < 12; i++) {
				let astroData = astrolabe.palaces[indexMap[i]]
			  let el = document.querySelector(`.zwds-grid .p${i}`);
			  el.classList.remove('selected')
			  if (i == p) {
			  	el.classList.add('selected')
			  	// console.log(JSON.stringify(astroData, true, 2))
			  }
			  let age = getAgesInRange(astroData.ages, min, max)
			  el.querySelector('.sectionB2-1').textContent = age
			  if (parseInt(age) > 0) {
			  	el.querySelector('.sectionB2-2').textContent = parseInt(age) + parseInt(astrolabe.rawDates.lunarDate.lunarYear) - 1
			  }
			}

			let el = document.querySelector(`.zwds-grid .p13 .right`);
			el.innerHTML = `
				Decade ${min} - ${max}
			`
		}

		function getTransformationType(stemKey, starName) {
		  const entry = transforms[stemKey+"Heavenly"];
		  if (!entry || !entry.mutagen) return null;

		  const index = entry.mutagen.indexOf(starName);
		  return index !== -1 ? index : null;
		}

		function getChineseYearPinyin(gregorianYear) {
		  const heavenlyStems = ['jia','yi','bing','ding','wu','ji','geng','xin','ren','gui'];
		  const earthlyBranches = ['zi','chou','yin','mao','chen','si','wu','wei','shen','you','xu','hai'];

		  const baseYear = 1984; // known jiazi year
		  const offset = gregorianYear - baseYear;

		  const stemIndex = (offset % 10 + 10) % 10;
		  const branchIndex = (offset % 12 + 12) % 12;

		  return [heavenlyStems[stemIndex], earthlyBranches[branchIndex]];
		}

		function setTransformationArrow(i) {
		  const svg = document.getElementById("lineLayer");
  		if (svg) {
  			svg.querySelectorAll("line").forEach(line => line.remove());
  		}

  		if (lastClickPalace == i) {
  			lastClickPalace = -1
  			return null
  		}

			lastClickPalace = i

			let id = `p${i}`
			let heavenlyStem = document.getElementById(id).dataset.heavenlyStem
			let stemData = transforms[heavenlyStem+"Heavenly"]
			if (!stemData || !stemData.mutagen) {
				return null
			}

			stemData.mutagen.forEach((target, index) => {
				if (index !== -1) {
					let color = labels[index].color
					
					if (index == 3) {						
						let target_id = document.getElementById(target).closest('[id^="p"]').dataset.palace						
						let opposite = palaceOpposites[parseInt(target_id)].opposite
						drawMultipleLines(target, ["p"+opposite], color, true, 'center', 'right')
						registerResizeRedraw(() => {
							drawMultipleLines(target, ["p"+opposite], color, true, 'center', 'right')
						})
					}
					
					drawMultipleLines(id, [target], color)
					registerResizeRedraw(() => {
						if (index == 0) {
							svg.querySelectorAll("line").forEach(line => line.remove());
						}
					  drawMultipleLines(id, [target], color)
					});
				}
			})
		}

		function drawMultipleLines(fromId, toIds, color, dash = false, targetSide = 'right', fromSide = 'center', maxLength = null, template = 'lineLayer') {
		  const container = document.querySelector('.zwds-grid');
		  const svg = document.getElementById(template);
		  const containerRect = container.getBoundingClientRect();
		  const fromEl = document.getElementById(fromId);
		  if (!fromEl) return;

		  const fromBox = fromEl.getBoundingClientRect();

		  let x1, y1;

		  switch (fromSide) {
		    case 'left':
		      x1 = fromBox.left - containerRect.left;
		      y1 = fromBox.top + fromBox.height / 2 - containerRect.top;
		      break;
		    case 'right':
		      x1 = fromBox.right - containerRect.left;
		      y1 = fromBox.top + fromBox.height / 2 - containerRect.top;
		      break;
		    case 'top':
		      x1 = fromBox.left + fromBox.width / 2 - containerRect.left;
		      y1 = fromBox.top - containerRect.top;
		      break;
		    case 'bottom':
		      x1 = fromBox.left + fromBox.width / 2 - containerRect.left;
		      y1 = fromBox.bottom - containerRect.top;
		      break;
		    case 'top-left':
		      x1 = fromBox.left - containerRect.left;
		      y1 = fromBox.top - containerRect.top;
		      break;
		    case 'top-right':
		      x1 = fromBox.right - containerRect.left;
		      y1 = fromBox.top - containerRect.top;
		      break;
		    case 'bottom-left':
		      x1 = fromBox.left - containerRect.left;
		      y1 = fromBox.bottom - containerRect.top;
		      break;
		    case 'bottom-right':
		      x1 = fromBox.right - containerRect.left;
		      y1 = fromBox.bottom - containerRect.top;
		      break;
		    case 'center':
		    default:
		      x1 = fromBox.left + fromBox.width / 2 - containerRect.left;
		      y1 = fromBox.top + fromBox.height / 2 - containerRect.top;
		      break;
		  }

		  toIds.forEach(toId => {
		    const toEl = document.getElementById(toId);
		    if (!toEl) return;

		    const toBox = toEl.getBoundingClientRect();

		    let x2 = (targetSide === 'right' ? toBox.right : toBox.left + toBox.width / 2) - containerRect.left;
		    let y2 = toBox.top + toBox.height / 2 - containerRect.top;

		    const dx = x2 - x1;
		    const dy = y2 - y1;
		    const distance = Math.sqrt(dx * dx + dy * dy);

		    if (distance > 0 && maxLength) {
		      let ratio = 1;
		      if (typeof maxLength === 'string' && maxLength.endsWith('%')) {
		        const percent = parseFloat(maxLength) / 100;
		        ratio = Math.min(percent, 1);
		      } else if (typeof maxLength === 'number') {
		        ratio = Math.min(maxLength / distance, 1);
		      }

		      x2 = x1 + dx * ratio;
		      y2 = y1 + dy * ratio;
		    }

		    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
		    line.setAttribute("x1", x1);
		    line.setAttribute("y1", y1);
		    line.setAttribute("x2", x2);
		    line.setAttribute("y2", y2);
		    line.setAttribute("stroke", color);
		    line.setAttribute("stroke-width", "1");
		    if (dash) {
		      line.setAttribute("stroke-dasharray", "5,3");
		    }
		    let arrow = template == 'lineLayer' ? 'arrow' : 'arrowShort'
		    line.setAttribute("marker-end", `url(#${arrow})`);
		    svg.appendChild(line);
		  });
		}

		function showShortLines() {
			let first_draw = -1
			for (let i = 0; i < 12; i++) {
				let id = `p${i}`
				let opposite = palaceOpposites[i].opposite

				let heavenlyStem = document.getElementById(id).dataset.heavenlyStem
				let stemData = transforms[heavenlyStem+"Heavenly"]
				if (!stemData || !stemData.mutagen) {
					return null
				}

				stemData.mutagen.forEach((target, index) => {
					if (index !== -1) {
						let color = labels[index].color
						let target_id = document.getElementById(target).closest('[id^="p"]').dataset.palace
						if (target_id == opposite) {
							if (first_draw == -1) {
 								first_draw = i
							}

							drawMultipleLines(id, [`p${target_id}`], color, false, 'center', palaceOpposites[i].direction, '5%', 'shortLineLayer')
							registerResizeRedraw(() => {
								if (i == first_draw) {
									const svg = document.getElementById("shortLineLayer");									
									svg.querySelectorAll("line").forEach(line => line.remove());
								}
								drawMultipleLines(id, [`p${target_id}`], color, false, 'center', palaceOpposites[i].direction, '5%', 'shortLineLayer')
							})
						}
					}
				})
			}
		}

		document.addEventListener('DOMContentLoaded', () => {
			const params = parseQuery();
			fillForm(params);

			// If URL has enough to plot, auto-draw:
			if (params.year && params.month && params.day) {
				generateChart(params);
			}

			// On form submit → reload with new query string
			document.getElementById('chartForm').addEventListener('submit', e => {
				e.preventDefault();
				const form = new FormData(e.target);
				const qs = new URLSearchParams(form).toString();
				window.location.search = qs;
			});

			let resizeTimeout;
			window.addEventListener('resize', () => {
			  clearTimeout(resizeTimeout);
			  resizeTimeout = setTimeout(() => {
			    requestAnimationFrame(redrawAllLines);
			  }, 50);
			});
		});
	</script>
</body>
</html>